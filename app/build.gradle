import com.android.build.api.variant.FilterConfiguration

apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'com.google.devtools.ksp'
apply plugin: 'kotlin-kapt'
apply plugin: 'kotlin-allopen'
apply plugin: 'jacoco'
apply plugin: 'com.github.kt3k.coveralls'
apply plugin: 'org.jetbrains.kotlin.plugin.serialization'

configurations.configureEach {
    resolutionStrategy {
        force deps.kotlin.stdlib
    }
}

jacoco {
    version = '0.8.1'
}

allOpen {
    annotation 'com.allVideoBrowserXmaster.OpenForTesting'
}
def splitApks = System.getenv("SPLITS_INCLUDE")?.toBoolean() ?: true
def abiFilterList = (properties["ABI_FILTERS"] as String).split(';')
def abiCodes = ["armeabi-v7a": 1, "arm64-v8a": 2, "x86": 3, "x86_64": 4]

android {
    compileOptions {
        coreLibraryDesugaringEnabled true
    }
    dependenciesInfo {
        // Disables dependency metadata when building APKs.
        includeInApk = false
        // Disables dependency metadata when building Android App Bundles.
        includeInBundle = false
    }

    ndkVersion "27.3.13750724"

    packagingOptions {
        resources {
            excludes += ['mozilla/public-suffix-list.txt',
                         'META-INF/*.kotlin_module',
                         'META-INF/DEPENDENCIES',
                         'META-INF/LICENSE',
                         'META-INF/LICENSE.txt',
                         'META-INF/license.txt',
                         'META-INF/NOTICE',
                         'META-INF/versions/9/OSGI-INF/MANIFEST.MF',
                         'META-INF/NOTICE.txt',
                         'META-INF/notice.txt',
                         'META-INF/ASL2.0',
                         'META-INF/*.kotlin_module']
        }
        jniLibs {
            useLegacyPackaging = true
            keepDebugSymbols += [
                    '**/libffmpeg.zip.so',
                    '**/libpython.zip.so',
                    '**/libffmpeg.so',
                    '**/libffprobe.so',
                    '**/libgojni.so',
                    '**/libpython.so',
                    '**/libqjs.so'
            ]
        }
    }
    compileSdkVersion build_versions.target_sdk
    signingConfigs {
        release {
            storeFile file(System.getenv("KEYSTORE_PATH") ?: "keystore.jks")
            storePassword System.getenv("KEYSTORE_PASSWORD")
            keyAlias System.getenv("KEY_ALIAS")
            keyPassword System.getenv("KEY_PASSWORD")
        }
    }
    defaultConfig {
        applicationId "com.myAllVideoBrowser"
        minSdkVersion build_versions.min_sdk
        targetSdkVersion build_versions.target_sdk
        versionCode 151
        versionName "0.8.8"

        if (splitApks) {
            splits {
                abi {
                    enable true
                    reset()
                    include 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
                    universalApk true
                }
            }
        } else {
            ndk { abiFilters.addAll(abiFilterList) }
        }
    }
    buildTypes {
        debug {
            minifyEnabled false
            shrinkResources false
            enableUnitTestCoverage false
            enableAndroidTestCoverage false
        }
        release {
            enableUnitTestCoverage false
            enableAndroidTestCoverage false
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    dataBinding {
        enabled = true
    }
    buildFeatures {
        viewBinding true
        buildConfig true
    }
    testOptions {
        unitTests.all {
            exclude '**/*'
        }
        unitTests {
            includeAndroidResources = true
            returnDefaultValues = true
        }
    }

    androidComponents {
        onVariants(selector().all()) { variant ->
            variant.outputs.forEach { output ->
                def name
                if (splitApks) {
                    name = output.filters.find { it.filterType == FilterConfiguration.FilterType.ABI }?.identifier
                } else {
                    name = abiFilterList[0]
                }

                def baseAbiCode = abiCodes[name]

                if (baseAbiCode != null) {
                    output.versionCode.set(baseAbiCode + (output.versionCode.get() ?: 0))
                }
            }
        }
    }
    namespace 'com.myAllVideoBrowser'
    lint {
        abortOnError false
    }
    sourceSets {
        main {
            jniLibs.srcDirs = ['src/main/jniLibs']
        }
    }
}

kotlin {
    jvmToolchain(21)
}

dependencies {
    // Android support
    implementation 'androidx.appcompat:appcompat:1.7.1'
    implementation 'com.google.android.material:material:1.13.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.2.1'
    implementation 'androidx.recyclerview:recyclerview:1.4.0'
    // Kotlin + coroutines
    implementation('androidx.work:work-runtime-ktx:2.11.0')

    // optional - RxJava2 support
    implementation('androidx.work:work-rxjava3:2.11.0')

    // optional - GCMNetworkManager support
    implementation 'androidx.fragment:fragment-ktx:1.8.9'
    // optional - Test helpers

    // optional - Multiprocess support
    implementation 'androidx.work:work-multiprocess:2.11.0'

    implementation 'androidx.legacy:legacy-support-v4:1.0.0'

    implementation('androidx.concurrent:concurrent-futures-ktx:1.3.0')

    // Kotlin
    implementation deps.kotlin.stdlib

    // Life cycle
    implementation deps.lifecycle.extensions
    implementation 'androidx.lifecycle:lifecycle-common-java8:2.10.0'
    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.10.0'
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.10.0'
    // Room

    implementation('androidx.room:room-runtime:2.8.4')

    ksp 'androidx.room:room-compiler:2.8.4'

    // optional - Kotlin Extensions and Coroutines support for Room
    implementation('androidx.room:room-ktx:2.8.4')

    // optional - RxJava3 support for Room
    implementation('androidx.room:room-rxjava3:2.8.4')

    // optional - Guava support for Room, including Optional and ListenableFuture
    implementation('androidx.room:room-guava:2.8.4')

    // Dagger2
    implementation deps.dagger.runtime
    implementation deps.dagger.android
    implementation deps.dagger.android_support
    ksp deps.dagger.compiler
    ksp deps.dagger.android_processor

    // OkHttp and Retrofit
    implementation deps.okhttp.runtime
    implementation deps.okhttp.logging
    implementation deps.retrofit.runtime
    implementation 'com.squareup.retrofit2:adapter-rxjava3:3.0.0'
    implementation deps.retrofit.gson

    implementation 'io.reactivex.rxjava3:rxandroid:3.0.2'
    // Because RxAndroid releases are few and far between, it is recommended you also
    // explicitly depend on RxJava's latest version for bug fixes and new features.
    // (see https://github.com/ReactiveX/RxJava/releases for latest 3.x.x version)
    implementation 'io.reactivex.rxjava3:rxjava:3.1.12'

    implementation("io.github.alexch33:youtubedl-android:0.18.1-alexch33-3")

    implementation("com.antonkarpenko:ffmpeg-kit-full-gpl:2.1.0")

    implementation 'com.github.bumptech.glide:glide:5.0.5'

    // Another Webview versions has random crashes
    implementation('androidx.webkit:webkit:1.12.1')

    implementation 'androidx.core:core-ktx:1.17.0'

    implementation 'org.jetbrains.kotlinx:kotlinx-serialization-json:1.9.0'
    implementation "org.jetbrains.kotlinx:kotlinx-serialization-core:1.9.0"
    // version change can break build
    implementation 'org.jsoup:jsoup:1.21.1'

    implementation 'com.github.marlonlom:timeago:4.1.0'

    var media3_version = '1.9.0'

    // For media playback using ExoPlayer
    implementation "androidx.media3:media3-exoplayer:$media3_version"

    // For DASH playback support with ExoPlayer
    implementation "androidx.media3:media3-exoplayer-dash:$media3_version"
    // For HLS playback support with ExoPlayer
    implementation "androidx.media3:media3-exoplayer-hls:$media3_version"
    // For RTSP playback support with ExoPlayer
    implementation "androidx.media3:media3-exoplayer-rtsp:$media3_version"

    // For building media playback UIs
    implementation "androidx.media3:media3-ui:$media3_version"

    // For extracting data from media containers
    implementation "androidx.media3:media3-extractor:$media3_version"

    // Common functionality for media database components
    implementation "androidx.media3:media3-database:$media3_version"
    // Common functionality for media decoders
    implementation "androidx.media3:media3-decoder:$media3_version"
    // Common functionality for loading data
    implementation "androidx.media3:media3-datasource:$media3_version"
    // Common functionality used across multiple media libraries
    implementation "androidx.media3:media3-common:$media3_version"
    implementation("androidx.media3:media3-datasource-okhttp:$media3_version")

    implementation "com.github.franmontiel:PersistentCookieJar:v1.0.1"

    // https://firebase.google.com/docs/android/setup#available-libraries

    implementation 'androidx.core:core-splashscreen:1.2.0'

    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.1.5")
}

ksp {
    arg("room.schemaLocation", "$projectDir/schemas".toString())
    arg("room.incremental", "true")
    arg("room.expandProjection", "true")
}

tasks.coveralls {
    dependsOn 'check'
    onlyIf { System.getenv("COVERALLS_REPO_TOKEN") }
}

// =========================================================================
// GO REPRODUCIBLE BUILD SETUP (Multi-Architecture)
// =========================================================================

ext {
    v2rayRepo = 'https://github.com/2dust/AndroidLibXrayLite.git'
    v2rayCommit = '93a711245dec705be8dd6aa6a47f8aafa7898c40'
    buildDirV2ray = file("${project.rootDir}/build/v2ray")
    // Resolve Go executable robustly: allow env/project override, check common install locations, fall back to PATH 'go'
    goExecutable = ({
        def envOverride = System.getenv('GO_EXECUTABLE')
        if (envOverride && file(envOverride).exists()) return envOverride
        if (project.hasProperty('GO_EXECUTABLE') && file(project.property('GO_EXECUTABLE')).exists()) return project.property('GO_EXECUTABLE')
        def candidates = ['/opt/homebrew/bin/go', '/usr/local/go/bin/go', '/usr/local/bin/go', '/usr/bin/go']
        def found = candidates.find { file(it).exists() }
        if (found) return found
        return 'go'
    })()
    gitExecutable = file('/usr/bin/git').exists() ? '/usr/bin/git' : 'git'
}

// Helper function to find the NDK path reliably
static def findNdkPath(Project project) {
    def envVar = System.getenv("ANDROID_NDK_HOME") ?: System.getenv("ANDROID_NDK_ROOT")
    if (envVar) {
        println "Found NDK path in environment variable: ${envVar}"
        return envVar
    }
    def localPropertiesFile = project.rootProject.file('local.properties')
    if (localPropertiesFile.exists()) {
        Properties properties = new Properties()
        localPropertiesFile.withInputStream { properties.load(it) }
        def propVar = properties.getProperty('ndk.dir')
        if (propVar) {
            println "Found NDK path in local.properties: ${propVar}"
            return propVar
        }
    }
    throw new GradleException("NDK path not found. Please define ANDROID_NDK_HOME, ANDROID_NDK_ROOT, or ndk.dir in local.properties.")
}

def ndkPath = findNdkPath(project)

// Detect the correct prebuilt toolchain folder inside the NDK (e.g. darwin-x86_64, linux-x86_64, windows-x86_64)
def prebuiltToolchainsDir = file("${ndkPath}/toolchains/llvm/prebuilt")
if (!prebuiltToolchainsDir.exists()) {
    throw new GradleException("NDK toolchains prebuilt directory not found at: ${prebuiltToolchainsDir}. Check your NDK installation and ndk.dir/ANDROID_NDK_HOME/ANDROID_NDK_ROOT settings.")
}

def prebuiltChildren = prebuiltToolchainsDir.listFiles()?.findAll { it.isDirectory() } ?: []
if (prebuiltChildren.size() == 0) {
    throw new GradleException("No prebuilt toolchain directory found under ${prebuiltToolchainsDir}.")
}

def ndkPrebuiltFolder = (prebuiltChildren.find { it.name.contains('darwin') } ?: prebuiltChildren[0]).name
println "Using NDK prebuilt folder: ${ndkPrebuiltFolder}"

def archConfigs = [
        'arm64-v8a'  : [goArch: 'arm64', target: 'aarch64-linux-android'],
        'armeabi-v7a': [goArch: 'arm', target: 'armv7a-linux-androideabi'],
        'x86_64'     : [goArch: 'amd64', target: 'x86_64-linux-android'],
        'x86'        : [goArch: '386', target: 'i686-linux-android']
]

// 1. Clones the V2Ray source code and checks out the specific commit.
tasks.register('cloneV2raySource') {
    group = "Go Setup"
    description = "Clones V2Ray source and checks out a specific commit."
    def srcDir = file("${buildDirV2ray}/src")
    outputs.dir(srcDir)
    onlyIf { !srcDir.exists() }

    doLast {
        println "--- Cloning V2Ray repository and checking out commit ${v2rayCommit} ---"

        // Step 1: Clone the default branch with a shallow history
        project.exec {
            workingDir project.rootDir
            commandLine gitExecutable, 'clone', '--depth=1', v2rayRepo, srcDir.absolutePath
        }

        // Step 2: Fetch the specific commit from the origin
        project.exec {
            workingDir srcDir
            commandLine gitExecutable, 'fetch', 'origin', v2rayCommit
        }

        // Step 3: Checkout the fetched commit
        project.exec {
            workingDir srcDir
            commandLine gitExecutable, 'checkout', v2rayCommit
        }
    }
}

// 2. Prepares the MAIN Go module and creates the vendor directory.
tasks.register('vendorGoDependencies') {
    group = "Go Setup"
    description = "Initializes main go.mod and creates a vendor directory."

    def builderDir = file("src/main/go/builder")
    def vendorDir = file("${builderDir}/vendor")

    // This task depends on the original, UNPATCHED source code.
    dependsOn tasks.named('cloneV2raySource')

    inputs.file("${builderDir}/builder.go")
    outputs.dir(vendorDir)

    // Pre-check: ensure the `go` executable is available and runnable before attempting to vendor.
    doFirst {
        println "--- (CHECK) Verifying Go executable ---"
        def overrideEnv = System.getenv('GO_EXECUTABLE')
        def overrideProp = project.hasProperty('GO_EXECUTABLE') ? project.property('GO_EXECUTABLE') : null
        def goExecCandidate = overrideEnv ?: overrideProp ?: goExecutable
        try {
            exec {
                workingDir builderDir
                commandLine goExecCandidate, 'version'
                // don't capture output; failure will throw an exception
            }
        } catch (Exception e) {
            throw new GradleException("Go executable not found or failed to run. Tried: ${goExecCandidate}.\nInstall Go (e.g. on macOS: 'brew install go') or set environment variable GO_EXECUTABLE=/path/to/go or pass -PGO_EXECUTABLE=/path/to/go. Original error: ${e.message}")
        }
    }

    doLast {
        println "--- Initializing main Go module and vendoring dependencies ---"

        def goModFile = file("${builderDir}/go.mod")

        goModFile.text = """
module builder
go 1.25.0

// This rule is copied from the AndroidLibXrayLite go.mod file.
// It forces the entire build to use the one, correct version of gvisor.
replace gvisor.dev/gvisor => gvisor.dev/gvisor v0.0.0-20250606001031-fa4c4dd86b43
"""
        file("${builderDir}/go.sum").delete()

        def goEnv = ['GOPROXY': 'https://proxy.golang.org,direct']

        // Step 1: Add the replace directive for our local clone.
        exec {
            workingDir builderDir
            environment goEnv
            commandLine goExecutable, 'mod', 'edit', '-replace=github.com/2dust/AndroidLibXrayLite=../../../../../build/v2ray/src'
        }

        // Step 2: Tidy the module. Go will now be forced to respect the top-level gvisor rule.
        exec {
            workingDir builderDir
            environment goEnv
            commandLine goExecutable, 'mod', 'tidy'
        }

        // Step 3: Create the vendor directory with the now-correct set of dependencies.
        exec {
            workingDir builderDir
            environment goEnv
            commandLine goExecutable, 'mod', 'vendor'
        }
    }
}


// 3. Update prepareGoBuild to depend on the final vendoring task
def prepareGoBuild = tasks.register("prepareGoBuild") {
    dependsOn tasks.named('vendorGoDependencies')
}

// 4. A placeholder task that the final Android preBuild will depend on.
def copyAllGoSharedLibs = tasks.register("copyAllGoSharedLibs") {
    group = "Go Build"
    description = "A placeholder task that aggregates all architecture-specific copy tasks."
}

// 5. Loop through each architecture to create build and copy tasks dynamically.
archConfigs.each { abi, config ->
    def goArch = config.goArch
    def target = config.target

    def buildTask = tasks.register("buildGoSharedLib_${abi}", Exec) {
        dependsOn prepareGoBuild
        group = "Go Build"
        description = "Builds the Go shared library for ${abi}."

        def builderDir = file("src/main/go/builder")
        def outputDir = file("${project.buildDir}/generated/go_build/${abi}")
        def outputSO = file("${outputDir}/libgojni.so")

        inputs.dir(builderDir)
        outputs.file(outputSO)

        workingDir builderDir

        def apiLevel = 21
        def toolchainPath = "${ndkPath}/toolchains/llvm/prebuilt/${ndkPrebuiltFolder}"
        def compiler = "${toolchainPath}/bin/${target}${apiLevel}-clang"
        def sysroot = "${toolchainPath}/sysroot"

        environment 'CGO_ENABLED', '1'
        environment 'GOOS', 'android'
        environment 'GOARCH', goArch
        environment 'CC', compiler
        environment 'CGO_CFLAGS', "--sysroot=${sysroot}"
        environment 'CGO_LDFLAGS', "--sysroot=${sysroot} -llog -Wl,-z,max-page-size=16384"

        doFirst {
            println "--- (BUILD) Executing Go build for ${abi} ---"
            if (!file(compiler).exists()) {
                throw new GradleException("C compiler for ${abi} not found at path: ${compiler}. Check NDK installation and path.")
            }
        }

        // Use '-mod=vendor' to force the compiler to use the local vendor directory.
        commandLine goExecutable, 'build',
                '-mod=vendor',
                '-buildmode=c-shared',
                '-trimpath',
                '-ldflags', "-s -w -buildid=",
                '-o', outputSO.absolutePath,
                '.'
    }

    def copyTask = tasks.register("copyGoSharedLib_${abi}", Copy) {
        dependsOn buildTask
        group = "Go Build"
        description = "Copies the Go shared library for ${abi} to jniLibs."

        from { buildTask.get().outputs.files }
        into "src/main/jniLibs/${abi}"

        doFirst {
            def sourceFile = buildTask.get().outputs.files.singleFile
            if (!sourceFile.exists()) {
                throw new InvalidUserDataException("Go build failed: ${sourceFile.path} was not created for ABI ${abi}.")
            }
            println "--- (COPY) Copying libgojni.so for ${abi} ---"
        }
    }

    // Add each copy task as a dependency for the final aggregate task.
    copyAllGoSharedLibs.configure {
        dependsOn copyTask
    }
}

// 6. Hook the final Go copy task into the Android build lifecycle.
project.afterEvaluate {
    tasks.named('preBuild').configure {
        dependsOn copyAllGoSharedLibs
    }
}
